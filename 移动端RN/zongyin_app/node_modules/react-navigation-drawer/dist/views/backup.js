

// _openingHandlerStateChange = ({ nativeEvent }) => {
//   if (nativeEvent.oldState === State.ACTIVE) {
//     this._handleRelease(nativeEvent);
//   } else if (nativeEvent.state === State.ACTIVE) {
//     this._emitStateChanged(DRAGGING, false);
//     if (this.props.keyboardDismissMode === 'on-drag') {
//       Keyboard.dismiss();
//     }
//     if (this.props.hideStatusBar) {
//       StatusBar.setHidden(true, this.props.statusBarAnimation || 'slide');
//     }
//   }
// };

// _onTapHandlerStateChange = ({ nativeEvent }) => {
//   if (
//     this._drawerShown &&
//     nativeEvent.oldState === State.ACTIVE &&
//     this.props.drawerLockMode !== 'locked-open'
//   ) {
//     this.closeDrawer();
//   }
// };

// _handleRelease = nativeEvent => {
//   const { drawerWidth, drawerPosition, drawerType } = this.props;
//   const { containerWidth } = this.state;
//   let { translationX: dragX, velocityX, x: touchX } = nativeEvent;

//   if (drawerPosition !== 'left') {
//     // See description in _updateAnimatedEvent about why events are flipped
//     // for right-side drawer
//     dragX = -dragX;
//     touchX = containerWidth - touchX;
//     velocityX = -velocityX;
//   }

//   const gestureStartX = touchX - dragX;
//   let dragOffsetBasedOnStart = 0;

//   if (drawerType === 'front') {
//     dragOffsetBasedOnStart =
//       gestureStartX > drawerWidth ? gestureStartX - drawerWidth : 0;
//   }

//   const startOffsetX =
//     dragX + dragOffsetBasedOnStart + (this._drawerShown ? drawerWidth : 0);
//   const projOffsetX = startOffsetX + DRAG_TOSS * velocityX;

//   const shouldOpen = projOffsetX > drawerWidth / 2;

//   if (shouldOpen) {
//     this._animateDrawer(startOffsetX, drawerWidth, velocityX);
//   } else {
//     this._animateDrawer(startOffsetX, 0, velocityX);
//   }
// };

// _updateShowing = (showing: boolean) => {
//   this._drawerShown = showing;
//   this._accessibilityIsModalView.current &&
//     this._accessibilityIsModalView.current.setNativeProps({
//       accessibilityViewIsModal: showing,
//     });
//   this._pointerEventsView.current &&
//     this._pointerEventsView.current.setNativeProps({
//       pointerEvents: showing ? 'auto' : 'none',
//     });
//   const { drawerPosition, minSwipeDistance, edgeWidth } = this.props;
//   const fromLeft = drawerPosition === 'left';
//   // gestureOrientation is 1 if the expected gesture is from left to right and -1 otherwise
//   // e.g. when drawer is on the left and is closed we expect left to right gesture, thus
//   // orientation will be 1.
//   const gestureOrientation =
//     (fromLeft ? 1 : -1) * (this._drawerShown ? -1 : 1);
//   // When drawer is closed we want the hitSlop to be horizontally shorter
//   // than the container size by the value of SLOP. This will make it only
//   // activate when gesture happens not further than SLOP away from the edge
//   const hitSlop = fromLeft
//     ? { left: 0, width: showing ? undefined : edgeWidth }
//     : { right: 0, width: showing ? undefined : edgeWidth };
//   this._panGestureHandler.current &&
//     this._panGestureHandler.current.setNativeProps({
//       hitSlop,
//       activeOffsetX: gestureOrientation * minSwipeDistance,
//     });
// };

// TODO: this is a big part of what needs to be updated
// _animateDrawer = (fromValue: ?number, toValue: number, velocity: number) => {
//   return;

// // TODO: setValue is not a thing now
// // this.state.dragX.setValue(0);
// // this.state.touchX.setValue(
// //   this.props.drawerPosition === 'left' ? 0 : this.state.containerWidth
// // );

// if (fromValue !== undefined) {
//   let nextFramePosition = fromValue;
//   if (this.props.useNativeAnimations) {
//     // When using native driver, we predict the next position of the animation
//     // because it takes one frame of a roundtrip to pass RELEASE event from
//     // native driver to JS before we can start animating. Without it, it is more
//     // noticable that the frame is dropped.
//     if (fromValue < toValue && velocity > 0) {
//       nextFramePosition = Math.min(fromValue + velocity / 60.0, toValue);
//     } else if (fromValue > toValue && velocity < 0) {
//       nextFramePosition = Math.max(fromValue + velocity / 60.0, toValue);
//     }
//   }
//   this.state.drawerTranslation.setValue(nextFramePosition);
// }

// const willShow = toValue !== 0;
// this._updateShowing(willShow);
// this._emitStateChanged(SETTLING, willShow);
// if (this.props.hideStatusBar) {
//   StatusBar.setHidden(willShow, this.props.statusBarAnimation || 'slide');
// }

// // TODO: fix this
// spring(this.state.drawerTranslation, {
//   velocity,
//   bounciness: 0,
//   toValue,
//   useNativeDriver: this.props.useNativeAnimations,
// }).start(({ finished }) => {
//   if (finished) {
//     this._emitStateChanged(IDLE, willShow);
//     if (willShow) {
//       this.props.onDrawerOpen && this.props.onDrawerOpen();
//     } else {
//       this.props.onDrawerClose && this.props.onDrawerClose();
//     }
//   }
// });
// };